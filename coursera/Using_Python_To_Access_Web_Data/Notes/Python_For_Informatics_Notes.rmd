<center> <h2>Python for Informatics (by Charles Severance) </h2> </center>
<center> <h3>---------------------------------------</h3> </center>

####*Python for Informatics - Chapter 2*

**A. Values and Types**

- do not use commas to write large numbers in Python
- it is a good idea to start variable names with a lowercase letter
- when you type a statement in interactive mode, it is executed immediately
    - otherwise, it will be executed at a time defined by your program's control structure
- operators = stuff like +, -, etc.
    - operands = stuff that is operated on
- if either operand is a float, python will do a float operation
    - if both are integers, and integer operation will be executed
    - 59/60 = 0 (remainder is chopped off)
- "in a script, expressions don't execute like they do interactively." You need to assign the result to something
- order of operations = PEDMAS
    - operators with the same precedence are evaluated left to right

**B. The Modulus Operator (%)**

- works on integers, prints the remainder
- modulus can be used to extract a few digits without having to go through string conversion

**C. String Operations**

- you can use ```raw_input()``` to prompt the user to type something
    - the result is a string, which can be converted with ```int()``` or ```float()``` if necessary

**D. Commenting and Variable Names**

- comments in python start with a hash
- "comments are most useful when they document non-obvious features of the code (such as WHY certain things are being done"
- "good variable names can reduce the need for comments, but long names can make complex expressions hard to read, so there is a trade-off"
- good variables names are *mnemonic*, meaning "memory aid"
    - use variable names to help show intent

**E. Debugging**

- if you spell a variable name wrong, you will get a "use before def" error

####*Python for Informatics - Chapter 3*

**A. Boolean Expressions**

- an expression that is either true or false
- "not equal" operator is "!="
- "is not" operator is "is not"
- any nonzero number is interpreted as "true"
    - "17 and True" evaluates to True
- if you want to write placeholder code, you can use ```pass``` in the body of a compound statement (like a loop or function)
- you actually can do if statements interactively as well!
    - meh. Not thrilled about this.
- chained conditional = "using elifs to do a bunch of different things)
- there is no limit on the number of ```elif``` statements you can use, but ```else``` can only be used once, at the end
- Dr. Chuck says to avoid nested conditionals (use ands and ors instead)

**B. Catching exceptions using try and except**

- the ```try``` and ```except``` framework is like an "insurance policy" for your code
- consider the following code, which asks for raw input but gives an explicit error handling

```{r eval=FALSE, engine='python'}
inp = raw_input('Enter Fahrenheit Temperature:')
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print cel
except:
    print 'Please enter a number'
```

- Python starts by executing the sequence of statements in the ```try``` block. IF all goes well, it skips the ```except``` block and proceeds. If an exception occurs in the ```try``` block, Python jumps out of the ```try``` block and executes the sequence of statements in the ```except``` block.
- this is called "catching an exception"

**C. Short-circuiting the Evaluation**

- when Python is processing a logical expression and decides that nothing is to be gained from further evaluation, it will stop immediately
    - for example, if an initial statement on the left of an "and" is False, it will immediately stop.
- This is called short-circuiting the evaluation
- you can construct expressions with a *guard evaluation* to avoid an error:
    - let's say that you are dividing by something and are scared that that thing might at some point be  0:
    - just put an "!= 0" statement at an early point in the list around the ```if``` statement. If it fails, Python will move on and there won't be any error
- traceback = "a list of the functions that are executing, printed when an exception occurs"

####*Python for Informatics - Chapter 4*

**A. Function Calls**

- function = "a named sequence of statements that performs a computation"
- a function gives you back a "return value"
- ```len``` gives character count
- conversion functions: ```float```, ```str```, ```int```

**B. Random numbers**

- ```random.random()``` gives you something between 0.0 and 1.0
- ```random.randint(low,high)``` returns an integer below low and high, including both
- ```random.choice(set)``` let's you randomly choose one element from a predefined set (i.e. a variable in your program)
- "the random module also provides functions to generate random values from continuous distributions including Gaussian, exponential, gamma, and a few more."

**C. Math functions**

- ```math.log()``` gives the natural log (log base e)
- use double quotes in functions where the input might have an apostrophe

**D. New Functions**

- defining a function creates a variable of the same name
- you can also use your function inside another function, even calling it multiple times if you want

**E. Definitions and uses**

- function definitions create function objects (so you don't have to keep repeating code)
- statements inside the function do not get executed until the function is called
- you should define your functions all upfront, so they're available to you later on in the program (you can't call functions that don't exist yet!)

**F. Flow of execution**

- generally speaking, statements are executed from top to bottom
    - however, if you call a function the program will go back and run the body statements of that function
- the story here: you don't necessarily want to read code from top to bottom. Follow the flow of execution!

**G. Parameters and arguments**

- ```math.pow(base,exponent)``` would give you something raised to some other power
- you can even pass expressions as arguments. For example:

```{r eval=FALSE, engine='python'}
# Define function
def print_twice(input):
    print input
    print input
    
# call it with a normal value
print('Hi, my name is')

#Returns:
"Hi, my name is
Hi, my name is"

# call with an expression
print('hello'*4)

# returns:
"hello hello hello hello
hello hello hello hello"
```

- don't worry about the name of the parameter...doesn't really matter, other than in defining your function

**H. Fruitful functions and void functions**

- fruitful functions - yield results
- void functions - perform some action (changing a variable, printing) but return nothing
- be sure to assign the result of fruitful functions to some variable
- void functions will return the special value ```None``` if you try to assign them to something
    - different from the string 'None'

**I. Why functions?**

- creating a new function gives you an opportunity to name a group of statements, making your program easier to read, understand, and debug
- functions can make a program smaller by eliminating repetitive code.
- dividing a long program into functions allows you to debug the parts one at a time and then assemble them into a working whole
- well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it

**J. Debugging**

- "If you are using a text editor to write your scripts, you might run into problems with spaces and tabs. The best way to avoid these problems is to use spaces exclusively (no tabs). Most text editors that know about Python do this by default, but some don't"
- be sure to save before running! (otherwise you'll be running an older version)

**K. Glossary**

- \textbf{algorithm} = a general process for solving a category of problems
- \textbf{composition} = using an expression as part of a larger expression, or a statement as part of a larger statement
- \textbf{pseudorandom} = pertaining to a sequence of numbers that appear to be random, but are generated by a deterministic program

####*Python for Informatics - Chapter 5*

**A. Updating Variables**

- ```while``` syntax:

```{r eval=FALSE, engine='python'}
n = 5
while n > 0:
    print n
    n = n - 1
print 'Blastoff!'
```

- execution flow:
    1. evaluate the condition, yielding True or False
    2. If the condition is false, exit the while statement and continue execution at the next statement
    3. If the condition is true, execute the body and then go back to step 1
- you can exit a loop with ```break```

**B. Finishing iterations with continue**

- you can use ```continue``` to skip to the next iteration immediately (not executing the rest of the code for that one iteration)
- check it out:

```{r eval=FALSE, engine='python'}
while True:
    line = raw_input('> ')
    if line[0] == '#':
        continue
    if line == 'done':
        break
    print line
print 'Done!'
```

**C. Definite loops using for**

- a for loop is considered "definite" because it just runs through a set of items until the set is expired
- check it out:

```{r eval=FALSE, engine='python'}
friends = ['Joseph', 'Glenn', 'Sally']
for friend in friends:
    print 'Happy New Year:', friend
print 'Done!'
```


**D. Loop patterns**

- loop flow is usually like this:
    1. initialize one or more variables before the loop starts
    2. Perform some computation on each item in the loop body, possibly changing the variables in the body of the loop
    3. look at the resulting variables when the loop completes
- you might sum selectively with an "accumulator" variable, for example
- to be fair though, we'd use ```len()``` or ```sum()``` in practice, rather than our own predefined functions

**E. Debugging**

- use binary search to debug:
    - look at half of program, then half of the half, etc. until you find an error
    - maybe use print statements so you can trace the program execution
- for a 100 line program, it will take you log~2~100, rather than 100, lines of checking!

####*Python for Informatics - Chapter 6*

**A. A string is a sequence**

- using negative indices counts backwards from the end of a string
    - ```print fruit[-1]``` would give the last letter of the string in the variable ```fruit```

**B. Strings are immutable**

- you cannot use the [] operator to change bits of strings

**C. Other Stuff**

- you can use a ```while:``` or ```for:``` loop to do a "traversal", looping over all elements of the string
- to count certain elements, you might use a "counter" loop, incrementing some counter when it hits whatever bit of string you're looking for
- the ```in``` operator is a boolean operator that takes two strings and returns True if the first appears as a substring in the second at least once
    - ```'a' in 'banana'``` will yield True

**D. Logical Operators**

- ```<``` and ```>``` refer to alphabetical order.
- note that in Python, all the uppercase letters come before all the lowercase letters
    - 'word' > 'bird'
    - 'Bird' > 'word'
    - 'George' == 'George'

**E. String methods**

- a string is a Python object, which means it contains data and methods
    - methods = functions built into the object available to any instance of the object
- the python function ```dir``` lists the methods available for an object
- the Python function ```type``` shows the type of an object
- you can also use the ```help``` function to retrieve documentation
- we invoke a method by appending it to the variable name using a period delimiter
    - functions are invoked, ethods are called
- the ```find``` method returns the index of the first occurrence of a  substring within the string
- you could do an ensemble of methods, which will be invoked left to right:
    - ```line.lower().startswith('p')``` would give you a boolean for whether or not the all-lowercase version of the string in the variable line starts with 'p'

**F. Format Operator**

- the format operator, %, allows us to construct strings, replacing parts of the strings with the data stored in variables
- kind of like a program string variable
- try this:

```{r eval=FALSE, engine='python;}
camels = 42
print 'I have spotted %d camels.' % camels

## Result
'I have spotted 42 camels.'


print 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')

## Result
'In 3 years, I have spotted 0.1 camels.'
```

- the second part...that set of comma-separated values in brackets is called a "tuple"

**G. Debugging**

- as you get better at programming, ask yourself:
    - "What could go wrong here?"
    - "What crazy thing might our user do to crash our (seemingly) perfect program?"

####*Python for Informatics - Chapter 7*

**A. Files: Persistence**

- so far, we've learned how to write programs and communicate out intentions to the CPU
- we've also learned how to create and use data structures in main memory
- files = "secondary memory"
    - permanent records on disk

**B. Opening Files**

- "opening" the file, in Python, just means creating a connection and verifying that the file is there
- opening returns a "handle" used to read the data, not the data itself
    ```file1 = open('stuff.txt')```
- the newline chracter = "\n"
    - this is a single character
- you might consider reading only a few lines at a time (to preserve space in main memory)

**C. Searching Through a File**

- a short script for only printing lines beginning with "From:"

```{r eval=FALSE, engine='Python'}

fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if line.startswith('From:') :
        print line
```

- the ```find()``` method returns -1 if the string is not found
- consider using try and except when asking for user input
- Quality Assurance = people who do crazy stuff to software to see how people might try to break it
- the ```exit()``` function terminates the program
- protecting the open call is a good example of the proper use of try and except in a Python program. We use the term "Pythonic" when we are doing something the "Python way".
- programming is part engineering and part art

**D. Writing Files**

- to write a file, open it with mode 'w'

```{r eval=FALSE, engine = 'Python'}
fout = open('output.txt', 'w')
print fout

# write a line to the file
line1 = "This here's the wattle, \n"
fout.write(line1)

## close the connection
fout.close()
```

**E. Debugging**

- use "\t" for a tab
- the built-in function ```repr``` can be useful. It takes any object as an argument and returns a string representation of the object.

####*Python for Informatics - Chapter 8*

**A. Lists**

- lists are enclosed in brackets, as in ```mylist = [2,4,5,6]```
- lists can include elements of mixed types (including other lists!)
- lists are mutable (unlike strings)
    - this means that you can change the order of items in a list or reassign an item in a list
- think of a list as a relationship between indices and elements. This relationship is called a mapping. Each index "maps to" one of the elements
- you can use the ```in``` operator to find something in a list, as in:
    - ```mylist = [1,2,3,4]```
    - ```check = 2 in mylist```

**B. Traversing a list**

- the most common way is in a for loop
- ```len()``` returns the number of elements in the list
- ```range()``` returns a list of indices from 0 to n-1, where n is the length of the list
- the length of the list is the number of elements (even if it contains other lists)

**C. List Operations**

- the ```+``` operator concatenates lists, the ```*``` operator repeats them
    - more precisely, it returns a list with the full original list repeated

**D. List Slices**

- omit the first index, the slice starts at the beginning
- omit the second, slice goes through the end
- "since lists are mutable, it is often useful to make a copy before performing operations that fold, spindle, or mutilate lists"

**E. List Methods**

- ```append()``` adds a new element to the end of the list
- ```extend()``` takes a list as an argument and appends all of its elements
    - as in ```list1.extend(list2)```
- ```sort()``` arranges the elements of the list
- most list methods are void, so don't assign them to variables!
    - "are void" = return None

**F. Deleting Elements**

- ```pop``` acts kind of like a Cut and paste.
- pull out the second value of mylist and assign it to x:
    - ```x = mylist.pop(1)```
- if you don't provide an index, it deletes and returns the final element
- you could use the ```remove()``` operator to do something similar-ish, although it returns None
- remove the word 'butter' from mylist:
    - ```mylist.remove('butter')```
- to remove more than one element, you can use ```del``` with a slice index

**G. Lists and Functions**

- ```len()```, ```max()```, ```min()```, ```sum()``` all operate on lists so you don't have to write for loops

**H. Lists and Strings**

- a list of characters is not the same as a string
- you can use ```split``` to break a string into words
    - split takes a delimiter argument to specify word boundaries
- the inverse of ```split()``` is ```join()```
    - join takes a list of stirngs and concatenates the elements. It is a string method, so you have to invoke it on the delimiter and pass the list as a parameter

**I. Parsing Lines**

- when reading from a file, you want to focus on only interesting parts of interesting lines
- consider the following, which reads a file and prints only the third word of only lines starting with "From"

```{r eval=FALSE, engine='Python'}
## Open the file
fhand = open('mbox-short.txt')

## Loop through lines, print 3rd word of lines starting with From
for line in fhand:
    line = line.rstrip()
    if not line.startswith('From ') : continue
    words = line.split()
    print words[2]
```

- note the use of the "contracted" if statement, with ```continue``` on the same line as the ```if```

**J. Objects and values**

- the association of a variable with an object is called a "reference"
- an object with more than one reference has more than one name, so we say that the object is aliased
- if the aliased object is mutable, changes made with one alias affect the other

**K. List Arguments**

- be careful to think about whether your functions are changing or creating lists

**L. Debugging**

- don't forget that most list methods modify the argument and return None
    - you can't write list code the same way you write string code
- make copies to avoid aliasing
- "when we read and parse files, there are many opporutnities to encounter input that can crash our program so it is a good idea to employ the guardian pattern"

####*Python for Informatics - Chapter 9*

**A. Dictionaries**

- a dictionary is a list, but more general
- unlike in a list (integer indices), a dictionary can have almost any type as an index
    - a mapping of key-value pairs
- key-value pair = "an item"
- ```dict()``` creates a new dictionary with no items
- the order of the dictionary is not as you might expect
    - it changes internally to maximize efficiency
- ```len()``` called on a dictionary returns the number of key-value pairs
- the ```in``` operator works on dictionaries (it tells whether something appears as a key in the dictionary)

**B. Searching Dictionaries vs. Lists**

- the in operator uses different algorithms for lists and dictionaries
- for lists, it uses a linear search algorithm (longer list = longer search)
- dictionaries use a hash table that has a remarkable property:
    - the in operator takes about the same amount of time no matter how many items there are in a dictionary

**C. Dictionary as a set of counters**

- the function ```ord()``` converts characters into integers
- and "implementation" is a way of performing a computation; and some are better than others!
- one advantage of the dictionary approach:
    - only store what we see, so no space wasted on zeros
- there is an awesome method for Python dictionaries called ```get()```
- the statement ```mydictionary.get('abc', 1)``` says "return the value associated with the key 'abc'. If you don't find that, return 1"

**D. Looping and Dictionaries**

- if you use a dicitonary as the sequence in a for statement, it iterates over the KEYS
- if you want alphabetical printouts, create a list of the keys (this is what ```listname.keys()``` returns) and then use the list method ```listname.sort()``` to sort it

**E. Advanced Text Parsing**

- the ```string``` module in Python contains some useful utilities for parsing text
- consider the following program (see comments):

```{r eval=F, engine='python'}
import string ## import "string" module
    
fname = raw_input('Enter the file name: ')
try:
    fhand = open(fname)
except:
    print 'File cannot be opened:', fname
    exit()
    
counts = dict()
for line in fhand:
    line = line.translate(None, string.punctuation) ## delete punctuation
    line = line.lower() ## coerce to lowercase
    words = line.split()
    for word in words:
        if word not in counts:
            counts[word] = 1
        else:
            counts[word] += 1
```

- learning to "think Pythonically" involves understanding that most common operations probably already have built-in Python functions to handle them

**F. Debugging**

- debugging by printing will become unwieldy very fast as we start working with bigger datasets
- some suggestions:
    1. work on small samples at first (to catch most errors), then slowly scale up the data size until you stop seeing issues
    2. Check summaries and types to make sure your data look the way you expect
    3. Write code with error-checks built in. It's generally good to have programs that break when you want them to
    4. Make your printed debugging statements prettier and give them structure
    
####*Python for Informatics - Chapter 10*

**A. Tuples**

- tuples are similar to lists, but immutable
- comma-separated lists (optionally in parentheses
- you might also use the function ```tuple()``` as such:
    - ```t = tuple('lupins')```
    - returns: ```('l','u','p','i','n','s')```
- you can slice these just like lists

**B. Comparison**

- comparison operators are evaluated item by item
- the following would evaluate to true:
    - ```(0,1,2000000) < (0,3,4)```

**C. Tuple Assignment**

- "one of the unique syntactic features of the Python language is the ability to have a tuple on the left side of an assignment statement. This allows you to assign more than one variable at a time when the left side is a sequence"

```{r eval=FALSE, engine='python'}
## In this example we have a two-element list and assign the 
## ...first and second elements of the sequence to the variables x and y

m = ['have','fun']
x,y = m
x
# 'have'
y
# 'fun'
```

- that syntax can parse any sequence...but it has to be of identical number of arguments
- dictionaries have an ```items``` methods that returns a list of key-value tuples
    - converting a dictionary to a list of tuples is a way to output the contents of a dictionary sorted by key

**D. Multiple Assignment with Dictionaries**

- "by carefully constructing the list of tuples to have the value as the first element of each tuple, we can sort the list of tuples and get our dictionary contents sorted by value"
- tuples are hashable (unlike lists), so we can use them to create composite dictionary keys

**E. Sequences: strings, lists, and tuples - Oh My!**

- many of the sequences (strings, lists, tuples) can be used interchangeably in many contexts
- a few notes:
    1. In some contexts, like a ```return``` statement, it is syntactically simpler to create a tuple than a list. In other contexts, you might prefer a list
    2. If you want to use a sequence as a dictioanry key, you have to use an immutable type like a tuple or string.
    3. If you are passing a sequence as an argument to a function, using tuples reduces the potential for unexpected behavior due to aliasing.
- "Because tuples are immutable, they don't provide methods like ```sort``` and ```reverse```, which modify existing lists. However, Python provides the built-in functions ```sorted``` and ```reversed```, which take any sequence as a parameter and return a new sequence with the same elements in a different order.

**F. Debugging**

- programming is accomplished by building a bit, seeing if it works, writing the next part, getting it to work again, etc.
- with these complex data structures, you can get some difficult-to-understand errors...when in doubt, strip it back down to the last working version, then start rebuilding
- random walk programming is a bad idea
- "finding a hard bug requires reading, running, ruminating, and sometimes retreating"
- reading your program won't always work...if it is not a syntactical error, you could read it 100 times and not see it..."because the error is in your head"
- immutable types are hashable, immutable types are not

####*Python for Informatics - Chapter 11*

**A. Regular Expressions**

- regular epxressions are powerful - but weird and complicated
- links:
    - http://en.wikipedia.org/wiki/Regular_expression
    - https://docs.python.org/2/library/re.html
- in Python, the regex library is in ```re```
- includes a ```search()``` function
- open the file, loop through each line, use search() to only print out lines that contain the string "From:"

```{r eval=False}
import re
hand = open('mbox-short.txt')
for line in hand:
    line = line.rstrip()
    
    # Find lines that contain "from"
    if re.search('From:', line) :
        print line

    # Find lines that start with "From:"
    if re.search('^From:', line) :
        print line
```

- the period ("full stop") matches exactly one character in regular expressions
- other stuff:
    - period --> match exactly one character
    - asterisk --> match 0 or more characters
    - plus sign --> match 1 or more characters
- match any line starting with "From" and then one or more characters followed by an at-sign:

```{r eval=FALSE, engine='python'}
import re
hand = open('mbox-short.txt')
for line in hand:
    line = line.rstrip()
    if re.search('^From:.+@', line):
        print line
```

**B. Extracting data using regular expressions**

- the "\S+" matches as many non-whitespace characters (at least one) as possible
- remeber that the "*" or "+" applies to the single character immediately to the left of the plus or asterisk
- ```re.findall()``` returns a Python list with all matching strings

**C. Combining searching and extracting**

- parentheses are another special character in regex
- when you add them to a reges, they are ignored when matching the string...but they indicate what you want to actually extract
- for example:

```{r eval=FALSE}
import re
hand = open('mbox-short.txt')
for line in hand:
    line = line.rstrip()
    x = re.findall('^X\S*: ([0-9.]+)',line)
    if len(x) > 0:
        print x
```

- remember, use ".*" as the "match anything" set

**D. Escape Character**

- you can use a front slash to escape special characters and literally match them
- remember, for example, that "$" matches the end of the line
- note the inside square brackets, characters are not "special"

**E. Summary**

- "^" matches the beginning of the line
- "$" matches the end of the line
- "." matches any character (a wildcard)
- "\s" matches a whitespace character
- "\S" matches a non-whitespace character
- "*" applies to the immediately preceding character and indicates to match 0 or more of the preceding characters
- "*?" applies to the immediately preceding character and indicates to match 0 or more of the preceding characters in "non-greedy mode"
    - this means "stop when you find the first match (prefer shortest)
- "+" applies to the immediately preceding character and indicates to match one or more of the preceding characters
- "+?" applies to the immediately preceding character and indicates to match one or more of the preceding characters in non-greedy mode
- "[aeiou]" matches a single character in the set
- "[a-z0-9]" matches single character in range of lowercase letters or digits
- "[^A-Za-z]" when the first character in the set is a caret, it inverts the logic. This matches a single character that is anything OTHER THAN an uppercase or lowercase letter
- "()" ignored for matching, used to tell regex functions what to be extracted
- "\b" matches the empty string, but only at the start or end of a word
- "\B" matches the empty string, but not at the start or end of a word
- "\d" matches any decimal digit; equivalent to the set "[0-9]"
- "\D" matches any non-digit character; equivalent to the set "[^0-9]"

**F. Bonus section for Unix users**

- on Unix, you can use grep (Generalized Regular Expression Parser)
- something like ```grep '^From:' mbox-short.txt```

**G. Debugging**

- use ```dir(re)``` to see all the methods in the ```re``` module
- you can get a bit of documentation with something in the form of ```help (re.search)```

**H. Vocab**

- \textbf{brittle code} - code that works when the input data is in a particular format but is prone to breakage if there is some deviation from the correct format.
- \textbf{greedy matching} - the notion that the "+" and "*" characters in a regular expression expand outward to match the largest possible string
- \textbf{grep} - a command vailable in most Unix systems that searches through text files looking for lines that match regular expressions. The command name stands for "Generalized Regular Expression Parser".
- \textbf{regular expression} - a language for expression complex search strings
- \textbf{wild card} - a special character that matches any character. In regular expressions the wild-card character is the period

####*Python for Informatics - Chapter 12*

**A. Networked Programs**

- "in this chapter we will pretend to be a web broswer and retrieve web pages using the HyperText Transport Protocol (HTTP)"
    - then we'll read through the web page data and parse it
    
**B. HyperText Transport Protocol - HTTP**

- ...there is built-in support in Python called ```socets``` which makes it very easy to make network connections and retrieve data over those sockets in a Python program
- a \textbf{socket} is much like a file, except that a single socket provides a two-way connection between two programs (read and write)
- some communication protocol is required to make sockets work
- HTTP is described here:
    - "http://www.w3.org/Protocols/rfc2616/rfc2616.txt"

**C. The World's Simplest Web Browser**

- a simple example:

```{r eval=FALSE}
import socket 

# Make a connection to port 80 on the server www.py4inf.com
mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect(('www.py4inf.com',80))

# Send a GET command followed by a blank line
mysock.send('GET http://www.py4inf.com/code/romeo.txt HTTP/1.0\n]n')

# With our response, receive 512-character chunks from the socket and print out data
while True:
    data = mysock.recv(512)
    if (len(data) < 1):
        break
    print data
 
mysock.close()
```

- the output of this request begins with descriptive headers from the web server
- the blank line added after the headers tells us that we should next expect the actual data of the file
- Python has a special library specifically design to support the HTTP protocol for retrieval of documents and data over the web

**D. Retrieving an image over HTTP**

- with ```recv()``` you get "up to" some number of characters (bytes) back
    - determined by whatever the server has sent at the moment recv() is called
    - might consider having the receiver "sleep" to let the server "get ahead" so that the average chunk size of ```recv()``` receipts is higher
- "there is a buffer between the server making send() requests and our app making recv() requests"
- "when we run the program with the delay in place, at some point the server might fill up the buffer in the socket and be forced to pause until our program starts to empty the buffer."
    - the pausing of either the sending applicaiton or the receiv app is called "flow control"
- Example:

```{r eval=FALSE}
import socket

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect(('www.py4inf.com',80))
mysock.send('GET http://www.py4inf.com/code/romeo.txt HTTP/1.0\n\n')

while True:
    data = mysock.recv(512)
    if (len(data) < 1):
        break
    print data
mysock.close()
```

- you can make calls to ```time.sleep()``` to slow down the calls

**E. Retrieving web page with urllib**

- urllib lets you treat a web page like a file
- try this:

```{r eval=FALSE}
import urllib

fhand = urllib.urlopen('http://www.py4inf.com/code/romeo.txt')
for line in fhand:
    print line.strip()
```

- urllib "consumes the headers" and only returns the data to us

**F. Parsing HTML and scraping the web**

- web scraping is when we write a program that pretends to be a web broswer and retrieves pages, then examines the data in those pages looking for patterns

**G. Parsing HTML using regular expressions**

- finding all the links:

```{r eval=FALSE}
import urllib
import re

url = raw_input('Enter - ')
html = urllib.urlopen(url).read()
links = re.findall('href=" (http://.?)"', html)
for link in links:
    print link
```

- regex parsing of HTML might struggle with all the weirdness out there
- this approach is really only appropriate if the HTML is well-formatted

**H. Parsing HTML using BeautifulSoup**

- try the [BeautifulSoup library](http://www.crummy.com/software/)
- BeautifulSoup tolerates highly flawed HTML and still lets you easily extract data you need
- try this:

```{r eval=FALSE}
import urllib
from BeautifulSoup import *

url = raw_input('Enter - ')
html = urllib.urlopen(url).read()
soup = BeautifulSoup(html)

# Retrieve all of the anchor tags
tags = soup('a')
for tag in tags:
    print tag.get('href', None)
```

**I. Reading binary files using urllib**

- sometimes you want binary (non-text) files like images or video files
- pulling down a binary file with a buffer

```{r eval=FALSE}
import urllib

img = urllib.urlopen('http://www.py4inf.com/cover.jpg')
fhand = open('cover.jpg', 'w')
size = 0
while True:
    info = img.read(100000)
    if len(info) < 1 : break
    size = size + len(info)
    fhand.write(info)
    
print size,'characters copied.'
fhand.close()
```

- the command ```curl``` in Unix = "copy url"
- the idea here is to copy and write bits of web data chunk by chunk

**J. GLossary**

- \textbf{BeautifulSoup} - a Python library for parsing HTML documents and extracting data from HTML documents
- \textbf{port} - a number that generally indicates which application you are contacting when you make a socket connection to a server. As an exmplae, web traffic usually uses port 80 while email traffic uses port 25
- \textbf{scrape} - when a program pretends to be a web browser and retrieves a web page, then looks at the web page content
- \textbf{socket} - a network connection between two applications where the applications can send and receive data in either direction
- \textbf{spider} - the act of a web search engine retrieving a page and then all the pages linked from a page and so on until they have nearly all the pages on the Internet which they use to build their search index
    
####*Python for Informatics - Chapter 13*

**A. Using Web Services**

- two common formats used when exchanging data across the web
- XML --> "eXtensible markup Language"
    - best suited for exchanging document-style data
- JSON --> "JavaScript Object Notation"
    - exchange of dictionaries, lists, internal information
    
**B. eXtensible Markup Language - XML**

- looks like HTML, but with more structure
- for example:

```{r eval=FALSE}
<person>
    <name>Chuck</name>
    <phone type="intl">
        +1 734 303 4456
    </phone>
    <email hide="yes"/>
</person>
```

- same idea as beautifulSoup and other parsers. You use ```.find()``` to identify the element, then either ```.text``` to get data between the tags or ```.get()``` to find some internal attribute
- each node can have some text, some attributes, and some "child" nodes
- using an XML parser such as ```ElementTree``` has the advantage that we can extract data from more complicated documents without worrying about the rules of XML syntax

**C. Looping Through Nodes**

- the ```findall``` method of ElementTree retrieves a Python list of subtrees that represent the structures of a particular type in the XML tree

**D. JavaScript Object Notation - JSON**

- Python was invented before JS, so its syntax for dictionaries and lists influenced the syntax of JSON
- unlike XML which has attributes, JSON has only key-value pairs
- "JSON structures are simpler than XML because JSON has fewer capabilities than XML"
- "JSON is quickly becoming the format of choice for nearly all data exchange between applications because of its relative simplicity compared to XML"

**E. Parsing JSON**

- example:

```{r eval=FALSE}
import json
input = '''
[
    { "id" : "001",
        "x" : "2",
        "name" : "Chuck"
    } ,
    { "id" : "009",
        "x" : "7",
        "name" : "Brent"
    }
]'''

info = json.loads(input)
print 'User count:', len(info)
for item in info:
    print 'Name', item['name']
    print 'Id', item['id']
    print 'Attribute', item['x']
```

- "we don't have to use the JSON library to dig through the parsed JSON, since the returned data is simply native Python structures"
- there is an industry trend away from XML and towards JSON for web services
- most word processors store documents internally using XML rather than JSON

**F. Application Programming Interfaces**

- "When we use an API, generally one program makes a set of services available for use by other applications and publishes the APIs (i.e., the "rules") that must be followed to access the services provided by the program."
- \textbf{Service-Oriented Architecture (SOA)} - when we begin to build our programs where the functionality of our program includes access to services provided by other program
- SOA approach is one where our overall application makes use of other apps
    - non-SOA would be a single self-contained program
- advantages of SOA:
    - always maintain only one copy of data
    - owners of the data can set the rules about the use of their data
- \textbf{web services} - when an application makes a set of services in its API available over the web

**G. Google geocoding web service**

- Google's maps API let's you take arbitrary text and get Google's best guess about location
    - the response is rich...includes lon/lat, city, state, country, etc.
- for example:

```{r eval=FALSE}
import urllib
import json

serviceurl = 'http://maps.googleapis.com/maps/api/geocode/json?'

while True:
    address = raw_input('Enter location: ')
    if len(address) < 1 : break
    
    url = serviceurl + urllib.urlencode({'sensor':'false',
        'address': address})
    print 'Retrieving', url
    uh = urllib.urlopen(url)
    data = uh.read()
    print 'Retrieved',len(data),'characters'
    
    try: js = json.loads(str(data))
    except: js = None
    if 'status' not in js or js['status'] != 'OK':
        print '==== Failure To Retrieve ===='
        print data
        continue
        
    print json.dumps(js, indent=4)
    
    lat = js["results"][0]["geometry"]["location"]["lat"]
    lng = js["results"][0]["geometry"]["location"]["lng"]
    print 'lat',lat,'lng',lng
    location = js['results'][0]['formatted_address']
    print location
```

- try www.py4inf.com/code/geojson.py and www.py4inf.com/code/geoxml

**H. Security and API Usage**

- "the vendor wants increased assurance of the source of the requests and so they expect you to send cryptographically signed messages using shared keys and secrets"
- check out ```OAuth()``` at http://www.oauth.net
- see some of the Twitter examples on pages 160-165 of the book
- in addition to the data we care most about, the HTTP response headers include a header "x-rate-limit-remaining", informing us how many more requests we can make before we will be shut off for a short time
- the "find the friends" of a particular account has a different rate limitation than the number of timeline queries we are allowed to run per time period
- generally speaking, the API rate limiting shouldn't prevent us from doing simple, personal data retrievals

**I. Glossary**

- \textbf{SOA} - Service-Oriented Architecture. When an application is made of components connected across a network.
- \textbf{XML} - eXtensible Markup Language. A format that allows for the markup of structured data.
- \textbf{ElementTree} - a built-in Python library used to parse XML data

####*Python for Informatics - Chapter 14*

**A. What is a database?**

- a file organized for storing data
- a key-value store on disk
- DB builds "indexes" to allow the computer to jump quickly to particular entries
- SQLite is designed to be embedded into other applications to provide them database support

**B. Database Concepts**

- table, row, column = relation, tuple, attribute

**C. Creating a Database table**

- you need to tell the DB software the names of each column and which types of data will be stored
- example:

```{r eval=F}
import sqlite3
    
conn = sqlite3.connect('music.sqlite3')
cur = conn.cursor()

cur.execute('DROP TABLE IF EXISTS Tracks')
cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')

conn.close()
```

- a cursor in Python works very similarly to a file handle
- SQL = "structured query language"
- you can use ```INSERT``` to put data into a table

```{r eval=FALSE}
import sqlite3
conn = sqlite3.connect('music.sqlite3')
cur = conn.cursor()

cur.execute('INSERT INTO Tracks (title, plays) VALUES ( ?, ? )',
( 'Thunderstruck', 20 ) )
cur.execute('INSERT INTO Tracks (title, plays) VALUES ( ?, ? )',
( 'My Way', 15 ) )
conn.commit() #force the data to be written to the db

print 'Tracks:'
cur.execute('SELECT title, plays FROM Tracks')
for row in cur :
print row
cur.execute('DELETE FROM Tracks WHERE plays < 100')
conn.commit()

```

- the ```cur``` is something we can loopover in the
- the cursor doesn't actually read all of the data when we execute 
- SELECT...instead, it reads on demand we loop through the rows in the for statement
- the output will be a tuple, with text data showing a u' to indicate Unicode encoding
- the WHERE clause selects specific rows

**D. Structured Query Language Summary**

- when we create a table, we indicate the names and types of the columns

```CREATE TABLE Tracks (title TEXT, plays INTEGER)```

- to insert a row into a table, we use the SQL ```INSERT``` command:

```INSERT INTO Tracks (title, plays) VALUES ('My Way', 15)```

- in a SQL ```WHERE``` clause we use a single equal sign to indicate a test for equality rather than a double equal sign
- other operators:
    - "<, >, <=, >=, !=, AND, OR"
- you can use ORDER BY to sort the returned rows
- you can use DELETE + WHERE to remove rows from the table
- you can use an UPDATE statement to update a column. For example:

```UPDATE Tracks SET plays = 16 WHERE title = 'My Way'```

- a single UPDATE statement will change all of the rows that match the WHERE clause
- these four basic SQL commands (INSERT, SELECT, UPDATE, and DELETE) allow the four basic operations needed to create and maintain data

**E. Spidering Twitter using a database**

- the trick in a spidering program is to start and stop many times without losing data
- maybe you'll want to store data as we retrieve it so our program can start back up and pick up where it left off
- an example:
```{r, eval=FALSE, engine='python'}
import urllib
import twurl
import json
import sqlite3

TWITTER_URL = 'https://api.twitter.com/1.1/friends/list.json'

conn = sqlite3.connect('spider.sqlite3')
cur = conn.cursor()

cur.execute(''' CREATE TABLE IF NOT EXISTS Twitter (name TEXT, retrieved INTEGER, friends INTEGER)''')

while True:
    acct = raw_input('Enter a Twitter account, or quit: ')
    if ( acct == 'quit' ) : break
    if ( len(acct) < 1 ) :
        cur.execute('SELECT name FROM Twitter WHERE retrieved = 0 LIMIT 1')
        try:
            acct = cur.fetchone()[0]
        except:
            print 'No unretrieved Twitter accounts found'
            continue
            
url = twurl.augment(TWITTER_URL,
        {'screen_name': acct, 'count': '20'} )

print 'Retrieving', url
connection = urllib.urlopen(url)
data = connection.read()
headers = connection.info().dict

# print 'Remaining', headers['x-rate-limit-remaining']
js = json.loads(data)

# print json.dumps(js, indent=4)

cur.execute('UPDATE Twitter SET retrieved=1 WHERE name = ?', (acct, ) )

countnew = 0
countold = 0
for u in js['users'] :
    friend = u['screen_name']
    print friend
    cur.execute('SELECT friends FROM Twitter WHERE name = ? LIMIT 1',
        (friend, ) )
    try:
        count = cur.fetchone()[0]
        cur.execute('UPDATE Twitter SET friends = ? WHERE name = ?',
            (count+1, friend) )
        countold = countold + 1
    except:
        cur.execute('''INSERT INTO Twitter (name, retrieved, friends)
            VALUES ( ?, 0, 1 )''', ( friend, ) )
        countnew = countnew + 1
print 'New accounts=',countnew,' revisited=',countold
conn.commit()

cur.close()
```

- the idea here is that because the data are stored on disk, you can stop and start as often as you like with no loss of data

**E. Basic data modeling**

- the real power of a relational datbaase is when we create multiple tables and make links between those tables
- data modeling = "the act of deciding how to break up your application data into multiple tables and establishing the relationships between the tables"
- database normalization = "we should never put the same string data in the database more than once"
- a string takes up a lot more space than an integer on the disk and in the memory of our computer, and takes mroe processor time to compare and sort
- you can use the UNIQUE keyword to ensure that only new data are added to the table
- by mapping w/ primary and foreign keys, we're modeling a relationship between tables

**F. Programming with Multiple tables**

- in a SELECT statement, you can pass the argument LIMIT 1 to ensure that you only get "the next record"

**F.1 Constraints in database tables**

- db constraints keep us from making mistakes such as adding the same relationship more than once
- INSERT OR IGNORE means "if the insertion violates rules in the table, then just ignore it (don't throw an error)"

**F.2 Retrieve and/or insert a record**

**G. Three kinds of keys**

- a logical key is a key that the "real world" might use to look up a row
    - e.g. "name"
- primary key is a number assigned automatically by the database
    - since these are integers, they take up very little storage and can be compared or sorted very quickly
- a foreign key is a number that points to the primary key of an associated row in a different table

**H. Using JOIN to retrieve data**

- you use JOIN in SQL to connect results across tables
- for example:

```
SELECT * FROM Follows JOIN People
    ON Follows.from_id = People.id WHERE People.id = 1
```

- JOINS may duplicate rows, as needed

**I. Summary**

- don't use a db unless you really need it
- situations where a database can be useful:
    - when your application needs to make many small random updates within a large data set
    - when your data is so large that it cannot fit in a dictionary and you need to look up information repeatedly
    - when you have a long-running process that you want to be able to stop and testart and retrain the data from one run to the next
- model your data efficiently so your programs run as fast as possible

**J. Debugging**

- see the "SQLite Database Browser"

####*Python for Informatics - Chapter 15*

**A. Building a Google map from geocoded data**

- imagine that you have a bunch of local survey data and want to use the google geocoding API to clean them up
- you might use a DB as a local cache of the results (since the API is rate-limited)

**B. Visualizaing Networks and interconnections**

**C. Visualizing Mail Data**

- 

####*Python for Informatics - Chapter 16*

**A. Automating common tasks on your computer**

####*Python For Informatics - Appendix A/B*

**A. Python Programming on Windows**

**B. Python Programming on Macintosh**
